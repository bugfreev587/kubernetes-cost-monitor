# Grafana Production Deployment Guide

This guide covers three critical aspects:
1. **Making Grafana publicly accessible**
2. **Tenant isolation using Grafana Organizations**
3. **Authorization and authentication**

---

## 1. Making Grafana Publicly Accessible

### Option A: Reverse Proxy (Recommended)

**Architecture:**
```
Internet → Domain (grafana.yourdomain.com) → Nginx/Traefik → Grafana:3000
```

#### Using Nginx

1. **Install Nginx:**
```bash
# On your server
sudo apt-get update
sudo apt-get install nginx certbot python3-certbot-nginx
```

2. **Create Nginx config:** `/etc/nginx/sites-available/grafana`

```nginx
server {
    listen 80;
    server_name grafana.yourdomain.com;

    # Redirect HTTP to HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name grafana.yourdomain.com;

    # SSL certificates (auto-generated by certbot)
    ssl_certificate /etc/letsencrypt/live/grafana.yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/grafana.yourdomain.com/privkey.pem;

    # SSL configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    # Proxy to Grafana
    location / {
        proxy_pass http://localhost:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        
        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
}
```

3. **Enable config and get SSL:**
```bash
sudo ln -s /etc/nginx/sites-available/grafana /etc/nginx/sites-enabled/
sudo nginx -t
sudo systemctl reload nginx
sudo certbot --nginx -d grafana.yourdomain.com
```

4. **Update Grafana config:**
```yaml
# docker-compose.grafana.yml
environment:
  - GF_SERVER_ROOT_URL=https://grafana.yourdomain.com
  - GF_SERVER_SERVE_FROM_SUB_PATH=false
  - GF_SECURITY_COOKIE_SECURE=true
```

#### Using Traefik (If using Docker Swarm/K8s)

```yaml
# docker-compose.grafana.yml
services:
  grafana:
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.grafana.rule=Host(`grafana.yourdomain.com`)"
      - "traefik.http.routers.grafana.entrypoints=websecure"
      - "traefik.http.routers.grafana.tls.certresolver=letsencrypt"
      - "traefik.http.services.grafana.loadbalancer.server.port=3000"
```

### Option B: Cloud Platforms

#### Railway
```yaml
# Railway automatically provides public URLs
# Set in environment variables:
GF_SERVER_ROOT_URL=https://grafana-production.up.railway.app
```

#### Kubernetes Ingress
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: grafana
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - grafana.yourdomain.com
    secretName: grafana-tls
  rules:
  - host: grafana.yourdomain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: grafana
            port:
              number: 3000
```

---

## 2. Tenant Isolation Using Grafana Organizations

### Concept

Each tenant gets their own Grafana **Organization**:
- Organization 1 = Tenant 1
- Organization 2 = Tenant 2
- Each org has isolated dashboards, data sources, and users

### Implementation Approaches

#### Approach 1: Auto-Create Organizations on Tenant Signup

**API Endpoint:** `POST /v1/admin/grafana/organizations`

```go
// Create Grafana organization when tenant is created
func (s *Server) createGrafanaOrg(tenantID int, tenantName string) error {
    // Call Grafana API to create org
    req := map[string]interface{}{
        "name": fmt.Sprintf("Tenant-%d", tenantID),
    }
    // POST to http://grafana:3000/api/orgs
    // Store org_id in tenants table
}
```

**Database Schema:**
```sql
ALTER TABLE tenants ADD COLUMN grafana_org_id INTEGER;
```

#### Approach 2: Provision Organizations via Config

**Using Grafana Provisioning:**
```yaml
# provisioning/orgs/orgs.yml
apiVersion: 1
organizations:
  - name: "Tenant-1"
    id: 1
    users:
      - username: "tenant1@example.com"
        org_role: "Admin"
  - name: "Tenant-2"
    id: 2
```

### Data Source Isolation

Each organization gets their own data source filtered by tenant_id:

```yaml
# provisioning/datasources/tenant-1-datasource.yml
apiVersion: 1
datasources:
  - name: TimescaleDB
    type: postgres
    orgId: 1  # Organization ID = Tenant ID
    url: tramway.proxy.rlwy.net:43259
    database: railway
    user: railway
    secureJsonData:
      password: ${GRAFANA_DB_PASSWORD}
    jsonData:
      sslmode: disable
      timescaledb: true
      # Use variable in queries: WHERE tenant_id = $tenant_id
```

### Switching Organizations in API

```go
// Switch user to their tenant's organization
func switchToTenantOrg(grafanaURL, adminToken, userEmail string, tenantOrgID int) error {
    // 1. Get user ID
    userID := getGrafanaUserID(grafanaURL, adminToken, userEmail)
    
    // 2. Add user to organization
    // POST /api/orgs/{org_id}/users
    // Body: {"loginOrEmail": userEmail, "role": "Viewer"}
    
    // 3. Switch user's active organization
    // POST /api/user/using/{org_id}
}
```

---

## 3. Authentication and Authorization

### Architecture Overview

```
User Login (Clerk) → API Server (JWT) → Grafana Auth Proxy → Grafana Org
```

### Option A: JWT Authentication (Recommended)

**Grafana JWT Auth:**

1. **Update Grafana config:**
```yaml
environment:
  - GF_AUTH_JWT_ENABLED=true
  - GF_AUTH_JWT_HEADER_NAME=X-JWT-Token
  - GF_AUTH_JWT_EMAIL_CLAIM=email
  - GF_AUTH_JWT_NAME_CLAIM=name
  - GF_AUTH_JWT_ORG_CLAIM=org_id
  - GF_AUTH_JWT_USERNAME_CLAIM=email
```

2. **API Server creates JWT for Grafana:**
```go
func (s *Server) generateGrafanaToken(userEmail string, tenantID int) (string, error) {
    claims := jwt.MapClaims{
        "email": userEmail,
        "org_id": tenantID,  // Tenant ID = Org ID
        "name": userEmail,
        "exp": time.Now().Add(24 * time.Hour).Unix(),
    }
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(os.Getenv("GRAFANA_JWT_SECRET")))
}
```

3. **Frontend redirects to Grafana with token:**
```typescript
// auth-service-frontend/src/hooks/useGrafanaAccess.ts
export function useGrafanaAccess() {
    const { user } = useUser();
    const { hasPlan } = usePricingPlan();
    
    const getGrafanaUrl = async () => {
        if (!hasPlan) {
            throw new Error("Pricing plan required");
        }
        
        // Get JWT from API server
        const response = await fetch('/v1/grafana/token', {
            headers: {
                'Authorization': `Bearer ${await user?.getToken()}`
            }
        });
        const { token } = await response.json();
        
        // Redirect to Grafana with token
        return `https://grafana.yourdomain.com/?auth_token=${token}`;
    };
    
    return { getGrafanaUrl };
}
```

### Option B: Auth Proxy (More Control)

**Create auth proxy service:**

```go
// Internal service: grafana-auth-proxy
func (p *AuthProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // 1. Extract token from request (Cookie/Header)
    token := extractToken(r)
    
    // 2. Validate token with API server
    user, tenantID, err := p.validateToken(token)
    if err != nil {
        http.Error(w, "Unauthorized", 401)
        return
    }
    
    // 3. Check pricing plan
    hasPlan, err := p.checkPricingPlan(tenantID)
    if err != nil || !hasPlan {
        http.Error(w, "Pricing plan required", 403)
        return
    }
    
    // 4. Ensure user exists in Grafana org
    orgID := tenantID
    p.ensureGrafanaUser(user.Email, orgID)
    
    // 5. Switch user to their org
    p.switchUserOrg(user.Email, orgID)
    
    // 6. Proxy request to Grafana
    p.proxy.ServeHTTP(w, r)
}
```

### Option C: OAuth Integration (Clerk OAuth)

**Grafana OAuth Config:**
```yaml
environment:
  - GF_AUTH_GENERIC_OAUTH_ENABLED=true
  - GF_AUTH_GENERIC_OAUTH_NAME=Clerk
  - GF_AUTH_GENERIC_OAUTH_CLIENT_ID=${CLERK_CLIENT_ID}
  - GF_AUTH_GENERIC_OAUTH_CLIENT_SECRET=${CLERK_CLIENT_SECRET}
  - GF_AUTH_GENERIC_OAUTH_SCOPES=openid email profile
  - GF_AUTH_GENERIC_OAUTH_AUTH_URL=https://your-clerk-domain.clerk.accounts.dev/oauth/authorize
  - GF_AUTH_GENERIC_OAUTH_TOKEN_URL=https://your-clerk-domain.clerk.accounts.dev/oauth/token
  - GF_AUTH_GENERIC_OAUTH_API_URL=https://your-clerk-domain.clerk.accounts.dev/oauth/userinfo
  - GF_AUTH_GENERIC_OAUTH_EMAIL_ATTRIBUTE_PATH=email
  - GF_AUTH_GENERIC_OAUTH_ALLOW_SIGN_UP=false
```

**Custom auth logic via OAuth:**
```go
// Middleware to set org_id based on user email
func (p *AuthProxy) setOrgFromEmail(email string, r *http.Request) {
    tenantID := p.getTenantIDFromEmail(email)
    r.Header.Set("X-Grafana-Org-Id", fmt.Sprintf("%d", tenantID))
}
```

---

## Complete Production Setup

### 1. Updated docker-compose.grafana.yml

```yaml
version: '3.8'

services:
  grafana:
    image: grafana/grafana:latest
    container_name: k8s_cost_grafana
    ports:
      - "3000:3000"
    environment:
      # Security
      - GF_SECURITY_ADMIN_USER=${GRAFANA_ADMIN_USER}
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD}
      - GF_SECURITY_SECRET_KEY=${GRAFANA_SECRET_KEY}
      - GF_SECURITY_COOKIE_SECURE=true
      - GF_SECURITY_COOKIE_SAMESITE=strict
      
      # Server
      - GF_SERVER_ROOT_URL=${GRAFANA_ROOT_URL}
      - GF_SERVER_SERVE_FROM_SUB_PATH=false
      
      # Users
      - GF_USERS_ALLOW_SIGN_UP=false
      - GF_USERS_AUTO_ASSIGN_ORG=false
      
      # Authentication (JWT)
      - GF_AUTH_JWT_ENABLED=true
      - GF_AUTH_JWT_HEADER_NAME=X-JWT-Token
      - GF_AUTH_JWT_EMAIL_CLAIM=email
      - GF_AUTH_JWT_NAME_CLAIM=name
      - GF_AUTH_JWT_ORG_CLAIM=org_id
      - GF_AUTH_JWT_USERNAME_CLAIM=email
      - GF_AUTH_JWT_EXPECT_CLAIMS={}
      
      # Organizations
      - GF_USERS_AUTO_ASSIGN_ORG_ID=1  # Default org (don't use in prod)
      
    volumes:
      - grafana-data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning
      - ./grafana/dashboards:/var/lib/grafana/dashboards
    depends_on:
      timescaledb:
        condition: service_healthy
    restart: unless-stopped

volumes:
  grafana-data:
```

### 2. Environment Variables (.env)

```bash
GRAFANA_ADMIN_USER=admin
GRAFANA_ADMIN_PASSWORD=<secure-password>
GRAFANA_SECRET_KEY=<generate-random-32-char-string>
GRAFANA_ROOT_URL=https://grafana.yourdomain.com
GRAFANA_JWT_SECRET=<same-secret-used-in-api-server>
GRAFANA_DB_PASSWORD=<timescaledb-password>
```

### 3. API Server Integration

**Add Grafana token endpoint:**
```go
// GET /v1/grafana/token
func (s *Server) getGrafanaToken(c *gin.Context) {
    // 1. Get user from Clerk JWT
    userEmail := c.GetString("user_email")  // From Clerk middleware
    tenantID := c.GetInt("tenant_id")       // From database
    
    // 2. Verify pricing plan
    var tenant models.Tenant
    if err := s.db.First(&tenant, tenantID).Error; err != nil {
        c.JSON(404, gin.H{"error": "tenant not found"})
        return
    }
    
    if tenant.PricingPlan == "" {
        c.JSON(403, gin.H{"error": "pricing plan required"})
        return
    }
    
    // 3. Generate Grafana JWT
    token, err := s.generateGrafanaJWT(userEmail, tenantID)
    if err != nil {
        c.JSON(500, gin.H{"error": "failed to generate token"})
        return
    }
    
    c.JSON(200, gin.H{
        "token": token,
        "grafana_url": os.Getenv("GRAFANA_ROOT_URL"),
    })
}
```

### 4. Frontend Integration

```typescript
// Dashboard.tsx
import { useGrafanaAccess } from '../hooks/useGrafanaAccess';

function Dashboard() {
    const { getGrafanaUrl } = useGrafanaAccess();
    
    const handleOpenGrafana = async () => {
        try {
            const url = await getGrafanaUrl();
            window.open(url, '_blank');
        } catch (error) {
            alert('Failed to access Grafana: ' + error.message);
        }
    };
    
    return (
        <button onClick={handleOpenGrafana}>
            Open Cost Dashboard
        </button>
    );
}
```

---

## Security Checklist

- [ ] SSL/TLS enabled (HTTPS only)
- [ ] Strong admin password
- [ ] Secret key rotated regularly
- [ ] JWT secret matches between API server and Grafana
- [ ] Cookie secure flag enabled
- [ ] Users can't sign up (GF_USERS_ALLOW_SIGN_UP=false)
- [ ] Each tenant has isolated organization
- [ ] Data sources filtered by tenant_id
- [ ] Pricing plan checked before access
- [ ] Rate limiting on auth endpoints
- [ ] CORS properly configured
- [ ] Firewall rules (only proxy exposed)

---

## Monitoring and Maintenance

### Health Checks
```bash
# Check Grafana health
curl https://grafana.yourdomain.com/api/health

# Check organization count
curl -H "Authorization: Bearer $ADMIN_TOKEN" \
  https://grafana.yourdomain.com/api/orgs
```

### Backup Grafana Data
```bash
# Backup dashboards, datasources, orgs
docker exec k8s_cost_grafana \
  grafana-cli admin export-dashboard > grafana-backup.json
```

### Logs
```bash
# View Grafana logs
docker logs -f k8s_cost_grafana

# Check auth failures
docker logs k8s_cost_grafana | grep -i "auth"
```

---

## Next Steps

1. **Set up reverse proxy** (Nginx/Traefik)
2. **Configure SSL** (Let's Encrypt)
3. **Update Grafana config** with production settings
4. **Implement JWT auth** in API server
5. **Create organizations** per tenant
6. **Test tenant isolation**
7. **Add Grafana link** to frontend dashboard

